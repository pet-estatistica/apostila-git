---
title: "Tutorial de Git"
author: "PET Estat√≠stica UFPR"
output:
  html_document:
    highlight: pygments
    toc: true
    theme: flatly
    keep_md: true
---

```{r, include=FALSE}
library(knitr)
opts_chunk$set(comment=NA)
```

<!--
## Processar com:
render git_tuto.Rmd
rm -rf meu1repo/ && rm -rf ~/maquina2/meu1repo/ && render git_tuto.Rmd

TODO
  * Remover o downloads. Fazer uma vez para uma pasta /Downloads e s√≥
    copiar de l√°. Manter o comandos com wget porque assim outras pessoas
    podem reproduzir.
  * Aprender o que fazer para n√£o precisar dar cd meu1repo em todos os
    chunks.

TODO Materiais a serem lidos
* http://www.atualsistemas.net/dev/Manual_Git.PDF
* http://www.dcc.fc.up.pt/~pbv/aulas/labprog/slides/gitprimer.pdf

## Wiki de um tutorial completo do Conselho Nacional de Justi√ßa.
http://www.cnj.jus.br/wikipje/index.php/GIT

## Slides com muitas ilustra√ß√µes.
http://wiki.softwarelivre.org/pub/Blogs/BlogPostAntonioTerceiro20081108115324/curso-vcs.pdf

## Compara servi√ßos de versionamento
http://www.ufjf.br/getcomp/files/2013/03/An%C3%A1lise-Comparativa-entre-Sistemas-de-Controle-de-Vers%C3%B5es-Daniel-Tannure-Menandro-de-Freitas.pdf

## Aproveita-se no glossario e cheat sheet
http://www.ceuma.br/nucleodeti/wp-content/uploads/2013/12/Git_v0.1.2.pdf
-->

<img src="https://git-scm.com/images/logos/downloads/Git-Icon-1788C.png"
width=200px align="right" display="block">

<!--==================================================================== -->

****
*Cheat sheets* para Git

  * [Tobias G√ºnther](http://www.git-tower.com/blog/git-cheat-sheet/);
  * [GitHub git cheat sheet](https://training.github.com/kit/downloads/github-git-cheat-sheet.pdf)
  * [Chris Sevilleja](https://scotch.io/bar-talk/git-cheat-sheet)
  * [Jan Kr√ºger](http://jan-krueger.net/wordpress/wp-content/uploads/2007/09/git-cheat-sheet.pdf)
  * [William Leeks](http://www.cheetyr.com/git)
  * [cheat.errtheblog.com](http://cheat.errtheblog.com/s/git)
  
O modelo de funcionamento do Git:

  * [patrickzahnd.ch](http://www.patrickzahnd.ch/wp-content/uploads/2014/02/git-transport-v1.pdf)
  * [Andrew Petenson](http://ndpsoftware.com/git-cheatsheet.html)

Playlists de tutoriais de Git

  * Loiane Groner - [Git e Github para iniciantes](https://www.youtube.com/watch?v=UMhskLXJuq4)
  * HxTutors - [Github - Pra que serve e como usar?](https://www.youtube.com/watch?v=neDiLHwXSVo)
  * Devmedia Editora - [Controle de versoes distribuido com Git](https://www.youtube.com/watch?v=1zj8ItHi_Kk)
  * RBtech - [Curso b√°sico de Git (playlist)](https://www.youtube.com/playlist?list=PLInBAd9OZCzzHBJjLFZzRl6DgUmOeG3H0)
  * Luiz Venturote - [Controle de Vers√£o com Git](https://www.youtube.com/playlist?list=PLBzQU3U8iMRndBoeUhURmQf1aLhQExbP8)
  * Leandro Cavalcante [Git (playlist)](https://www.youtube.com/watch?v=GBnt3ztA6nI&list=PLXtEEPEfASEIrUZj9X_kj-dlaul59bRox)
  * StudyClassOficial - [Controle de Vers√£o com GIT](https://www.youtube.com/watch?v=Wj8EB4IAqWc)
  * Israel Santos - [Controle de vers√£o com git](https://www.youtube.com/watch?v=morEwdyzmY4)
  * Giovanni Silva - [Tutorial Git (playlist)](https://www.youtube.com/playlist?list=PL3NGePwPGuvvnBO4tk---xNABmNVEpD2R)
  * makigas - [Tutorial de Git en media hora](https://www.youtube.com/watch?v=QGKTdL7GG24)
  * Desde Cero - [C√≥mo Instalar Git en Windows Desde Cero](https://www.youtube.com/watch?v=poVAyKNsk00)

****
## O que È o Git?

O Git È uma ferramenta de controle de vers√£o que facilita os projetos em equipe 
a verficaÁ„o do mesmo. Basicamente, o Git detecta as mudanÁas que ocorrem no
arquivo, bem como onde ocorreu e qual mudanÁa foi feita. Ainda existe a
possibilidade de voltar no histÛrico do projeto, sempre que necess·rio.
Outra facilidade est· na equipe trabalhar em cima do projeto ao mesmo tempo,
e no final o Git faz o trabalho de juntar todos os arquivos mostrando se h·
algum conflito. Integrantes podem mandar sugestıes de alteraÁıes, e cabe ao
respons·vel pelo projeto incorporar ou n„o essas alteraÁıes.

Criado em 2005 por Linus Torvalds, tambÈm criador do Linux, o Git surgiu a partir da necessidade de desenvolver uma ferramenta b·sica que pudesse lidar com projetos grandes de maneira eficaz. Linus colocou o nome Git em referÍncia a si mesmo, que no inglÍs brit‚nico È uma gÌria para "cabeÁa-dura". 

****
## Download e instala√ß√£o

A primeira coisa a fazer √© ter instalado os arquivos necess√°rios para o
Git funcionar. Em sistemas Debian e suas varia√ß√µes (Ubuntu, LinuxMint,
...), os pacotes necess√°rios podem ser instalados com comandos que, a
partir dos reposit√≥rios de cada distribui√ß√£o, instalam o Git na sua
m√°quina.

**Linux**

Em uma sess√£o de terminal Linux de distribui√ß√µes Debian (Ubuntu, Mint),
execute o c√≥digo abaixo.

```{r, engine="sh", eval=FALSE}
## Adicione o ppa para ter a vers√£o mais recente do Git. Descomente e
## rode essas duas linhas de comando para isso.
## sudo add-apt-repository ppa:git-core/ppa
## sudo apt-get update

sudo apt-get install git git-core git-man git-gui git-doc \
    ssh openssh-server openssh-client
git --version

## Ferramentas complementares.
sudo apt-get install gitk meld
```

Usu√°rios de Linux baseados no Arch instalam de uam forma ligeiramente
diferente.

```{r, engine="sh", eval=FALSE}
pacman -S git openssh meld
git --version
```

O `ssh` e `openssh-*` s√£o necess√°rios para a comunica√ß√£o entre sua
m√°quina e o servidor do GitHub ou GitLab. Iremos configurar reposit√≥rios
remotos em uma outra sess√£o. O Git tamb√©m pode ser instalado em ou
sistemas operacionais. Visite [Installing-Git][] e siga as
instru√ß√µes. Os arquivos de instala√ß√£o podem ser baixados do endere√ßo
<http://git-scm.com>.

**Windows**

Usu√°rios Windows devem visitar <https://git-for-windows.github.io/>,
baixar e instalar. Essa instala√ß√£o do Git traz o [**Git BASH**][] que √© como
um terminal do (Li|U)nix, a [**Git GUI**][] que √© uma interface para
trabalhar com Git e [**Shell Integration**][] que s√£o a√ß√µes dispon√≠veis no
menu aberto pelo bot√£o direto mouse. Al√©m disso, segundo o que consta √©
que essa instala√ß√£o tras tamb√©m a [**Gitk**][], uma interface para navega√ß√£o
no hist√≥rico.

[Meld](http://meldmerge.org/) √© um assistente de compara√ß√£o de arquivos
(*file diff*). Ele √© muito √∫til como ferramenta para resolver conflitos
de merge (*mergetool*). No entanto, n√£o √© obrigat√≥rio ter.

****
## Configurando perfil

Estas configura√ß√µes precisam ser feitas apenas uma vez, e servem para
determinar algumas op√ß√µes globais do Git.

Os comandos abaixo v√£o configurar o nome de usu√°rio e email. Fique
tranquilo que o Git n√£o vai te enviar email, isso √© apenas informa√ß√£o
que ficar√° associada ao trabalho que voc√™ desenvolver de modo a permitir
que os colaborados/gestores do projeto identifiquem suas contribui√ß√µes e
possam entrar em contato, se necess√°rio (principalmente se voc√™ fizer
aqui de errado). Mesmo que voc√™ nunca venha a trabalhar em equipe,
apenas localmente, √© importante fornecer nome e email. Se trabalhar de
duas m√°quinas diferentes, voc√™ pode indentificar no nome de usu√°rio.

```{r, engine="sh", eval=FALSE}
## Configura√ß√µes do Git do Batman.
git config --global user.name "Knight Rider"
git config --global user.email "batman@justiceleague.org"

## Configura√ß√µes do Git do Superman.
git config --global user.name "Kal-El"
git config --global user.email "superman@justiceleague.org"
```

O `--global` dessa instru√ß√£o significa que o que for definido vai valer
para todo projeto Git da m√°quina. √â poss√≠vel fazer defini√ß√µes para cada
projeto, ou seja, n√£o globais. Portanto, voc√™ pode trabalhar com nomes
ou emails diferentes para cada projeto. √â poss√≠vel tamb√©m criar `alias`
para algumas intru√ß√µes Git. Embora elas n√£o sejam t√£o longas, no uso
cont√≠nuo pode valer a pena. Visite:

  * [Setting up a repository][]
  * [Customizing Git - Git Configuration][]

Al√©m disso podemos definir um editor de texto padr√£o para escrever as
mensagens de *commits*. Por padr√£o, esse editor √© o `$EDITOR` do seu
shell. (Essa etapa pode ser pulada a princ√≠pio, como veremos mais pra
frente). Esse editor n√£o precisa ser necessariamente o mesmo editor que
voc√™ usa para escrever [texto, c√≥digo]. No meu caso uso o Emacs, mas
para essa tarefa prefiro o vim por ser um editor embutido, e que n√£o vai
carregar uma interface gr√°fica desnecessariamente quando for preciso
escrever uma mensagem de *commit*. Portanto, aqui pode-se deixar espa√ßo
para o `vim`.

```{r, engine="sh", eval=FALSE}
git config --global core.editor vim
```

O Emacs tamb√©m pode ser carregado embutido no terminal (sem usar o X),
usando a op√ß√£o `emacs -nw` (de *no window*) na sua inicializa√ß√£o.

No Linux, as informa√ß√µes acima passadas ficam salvas em um arquivo na
home do usu√°rio chamado `.gitconfig`. Quando n√£o se usa o `--global`, as
defini√ß√µes ficam salvas dentro do pr√≥prio do projeto. Eis o conte√∫do do
arquivo de configura√ß√£o do Batman.

```{r, engine="bash", eval=FALSE}
less ~/.gitconfig
```

```
[user]
    name = Knight Rider
    email = batman@justiceleague.org
[merge]
    tool = meld
```

No caso dele, al√©m de nome e email, tem que o `meld` que √© a ferramenta
de merge definida como padr√£o. Para conseguir isso voc√™ precisa definir
como fez com os demais ([how-to-set-meld-as-git-mergetool][]).

```{r, engine="bash", eval=FALSE}
git config --global merge.tool meld
```

**Avan√ßado**: Para usu√°rios Linux que apreciam o n√≠vel de customiza√ß√£o
que o Linux oferece (como o Batman e n√≥s), √© poss√≠vel configurar o
prompt do terminal para mostrar a informa√ß√£o do ramo, usu√°rio, etc. Essa
informa√ß√£o estampada facilita um bocado, principalmente em projetos
grandes. Visite:

  * [Eranga Bandara](https://coderwall.com/p/fasnya/add-git-branch-name-to-bash-prompt)
  * [Michael Hoffman](http://code-worrier.com/blog/git-branch-in-bash-prompt/)

****

## Criar um projeto versionado

### Instru√ß√µes do Git

J√° temos o Git devidamente e com credenciais (nome e email) e
configura√ß√µes aplicadas. Vamos ent√£o ver como o sistema de controle de
vers√£o acontece.

Todas as instru√ß√µes do Git s√£o sinalizadas por come√ßar com `git` seguido
da instru√ß√£o/comando e seus argumentos complementares, se
existirem/necess√°rios.

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## Padr√£o de instru√ß√µes Git.
git <instru√ß√£o> <complementos ...>
```

Os comandos abaixo revelam tudo o Git tem, embora dizer o que ele tem
n√£o signifique nada diante do que ele pode fazer com o que tem.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Ajuda resumida do Git, principais comandos com descri√ß√£o.
git help -a
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Lista de todos os comandos dispon√≠veis.
git help -a
```

### Criar um diret√≥rio para o projeto Git

Vamos criar um diret√≥rio vazio para come√ßarmos um projeto. Tamb√©m se
pode come√ßar de um diret√≥rio que j√° tenha arquivos e subdiret√≥rios. Voc√™
pode fazer isso com seu *file manager* padr√£o que no Ubuntu √© o
[`Nautilus`](https://wiki.gnome.org/action/show/Apps/Nautilus), no Mint
√© o `Nemo`.

**NOTA**: o desenvolvimento do Nemo √© feito com Git e est√° dispon√≠vel no
GitHub: [linuxmint/nemo][].

Nesse tutorial, as instru√ß√µes ser√£o todas feitas no terminal mesmo que
existam alternativas gr√°ficas para as mesmas. Isso enfatiza no que est√°
sendo feito al√©m do fato de que no terminal todos devem ter os mesmos
recursos e os comandos ir√£o produzir os mesmos resultados, o que faz
esse tutorial algo reproduz√≠vel. Se voc√™ considera que uma ferramenta
gr√°fica √© mais confort√°vel ou produtiva, sinta-se √† vontade para
aprend√™-la e us√°-la.

```{r, engine="bash", include=FALSE}
if [ -d meu1repo ]
then
    echo "Diret√≥rio existe. Ent√£o apagar pasta .git"
    cd meu1repo
    ls -a
    if [ -d .git ]
    then
        echo "J√° existe projeto git aqui. Apagar."
        rm -rf .git/
        rm -rf *
    fi
else
    echo "Diret√≥rio n√£o existe."
    mkdir meu1repo
fi

## Tudo limpo tal como precisamos.
pwd
ls -a
```

```{r, engine="bash", eval=FALSE}
## Cria diret√≥rio (make directory).
mkdir meu1repo

## Entra no diret√≥rio (change directory).
cd meu1repo
```

Antes de iniciarmos o reposit√≥rio, vamos s√≥ verificar o cadastro. Se
voc√™ j√° usa o Git ou fez os procedimento apresentados na primeira
sess√£o, o comando abaixo vai retornar o nome e email usados e alguns
defini√ß√µes adicionais, caso existam. Em caso de ainda n√£o ter
configurado o seu Git, informe o nome e email conforme apresentado na
sess√£o anterior.

```{r, engine="bash", eval=FALSE}
## Mostra as informa√ß√µes/defini√ß√µes do usu√°rio.
git config --list
```

```sh
user.name=Knight Rider
user.email=batman@justiceleague.org
merge.tool=meld
```

Temos um diret√≥rio destinado ao projeto que ser√° mantido sobre
versionamento, ent√£o vamos iniciar um reposit√≥rio Git nele.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Inicia um reposit√≥rio sob versionamento Git.
git init
```

O Git retorna a mensagem de iniciliza√ß√£o do reposit√≥rio. Nesse momento
ele cria um diret√≥rio oculto `.git/` com subdiret√≥rios que s√£o o cora√ß√£o
do sistema de versionamento. Voc√™ n√£o deve modificar nada nesse
diret√≥rio. √â por essa raz√£o que ele √© oculto. Alterar o conte√∫do pode
prejudicar ou interromper o funcionamento do Git. Se voc√™ quiser
encerrar o processo de versionamento fazendo com que esse diret√≥rio seja
como qualquer outro diret√≥rio, √© s√≥ excluir a diret√≥rio `.git/`. Cada
subdiret√≥rio do `.git/` tem um prop√≥sito mas deixaremos os
esclarecimentos para o futuro. Por agora vamos apenas conferir a sua
estrutura.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra todo conte√∫do do diret√≥rio.
tree -a
```

**NOTA**: o `tree` √© um programa instalado a parte (*third party
software*) que retorna arte ASCII representado a estrutura de
diret√≥rios. Se voc√™ usa distribui√ß√£o Debian, instale com `sudo apt-get
install tree`. Windows: [tree][].

Vamos come√ßar da maneira mais simples: criando um arquivo com uma linha
de texto apenas. Bem, vale avisar que ao longo desse tutorial, os
arquivos ser√£o sempre bem pequenos e dificilmente realistas, mas como o
enfoque est√° no funcionamento, n√£o haver√° preju√≠zo.

Vamos criar o arquivo com conte√∫do tamb√©m pelo terminal. Se voc√™
preferir, abra eu editor de texto favorito (Emacs, Gedit, Geany,
RStudio, etc) e fa√ßa algo mais criativo.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Cria um arquivo com uma linha de conte√∫do.
echo "Meu primeiro reposit√≥rio Git" > README.txt

## Lista os arquivos do diret√≥rio.
tree
```

O Git est√° "atento" a tudo que acontece nesse diret√≥rio. Ao criarmos o
arquivo e pedirmos a situa√ß√£o (*status*), ele indica que existe um
arquivo n√£o restreado (*untracked*) no diret√≥rio. Inclusive sugere uma
a√ß√£o que seria adicionar o aquivo (*add*). Se o seu sistema operacional
est√° em portugu√™s, parte dos outputs do Git podem estar traduzidos.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Reconhecimento do Git sobre aquivo criado.
git status
```

Para que o arquivo seja inclu√≠do no monitoramento √© necess√°rio que ele
receba o primeiro comando *add*. Isso marca a entrada dele no projeto
como um arquivo que a partir de ent√£o ser√° versionado. O *status* agora
n√£o indica mais que ele est√° *untracked* mas sim que existem mudan√ßas
para serem registradas (*changes to be commited*). A melhor tradu√ß√£o de
*commit*, pensando no seu uso em Git, √© **fechar sob seguran√ßa**. Quando
um *commit* √© feito, cria-se um instante na linha do tempo que salva o
estado do projeto. Para esse instante o projeto pode ser retrocedido,
voltando o condi√ß√£o/conte√∫do de todos os arquivos para o momento no qual
o mencionado *commit* foi feito. Voc√™ pode voltar para um *commit* de
semanas e at√© anos atr√°s.

O controle de vers√£o n√£o √© apenas voltar os arquivos para o conte√∫do que
eles tinham no passado. Arquivos rastreados que foram deletados ou
renomeados s√£o recuperados. At√© mesmo as permiss√µes de
leitura/escrita/execuss√£o dos arquivos s√£o comtempladas no
versionamento.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## O primeiro `add` submete o arquivo ao versionamento.
git add README.txt
git status
```

O arquivo `README.txt` j√° √© visto pelo Git como um arquivo com o qual
ele deve se "preocupar", pois est√° sob versionamento. Vamos agora fazer
um registro definitivo sobre o estado desse arquivo (*commit*). √â de
fundamental import√¢ncia que a mensagem de notifica√ß√£o, ou mensagem de
*commit*, reflita as mofica√ß√µes feitas. S√£o as mensagens que ser√£o
consultadas quando voc√™ precisar desfazer/voltar. Ela deve ser curta (<=
72 caracteres) e ao mesmo tempo informativa. A minha primeira mensagem
n√£o ser√°, todavia.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Registro de vers√£o.
git commit -m "Cria arquivo com t√≠tulo."
```

**NOTA**: Sobre mensagens de *commit* e trabalho colaborativo em Git
existem algumas boas pr√°ticas que devem ser seguidas. Visite:
[Git contributing guide][].

O retorno da instru√ß√£o de *commit* indica o n√∫mero de arquivos inclu√≠dos
no *commit* e o n√∫mero de inser√ß√µes e dele√ß√µes de linhas. O mais
importante est√° na primeira linha que informa o ramo de trabalho atual
(*branch*) e o *sha1* do *commit*. O *sha1* √© uma sequ√™ncia hexadecimal
de 40 digitos que representa unicamente o *commit*, ent√£o s√£o $16^40$
possibilidades!. √â por meio do *sha1* que podemos retroceder o
projeto. S√£o mostrados apenas os 7 primeiros digitos porque s√£o
suficientes para diferenciar *commits* dentro at√© mesmo de projetos
moderados ou grandes. Visite: [sha1-size][].

Vamos criar mais arquivos e acrescentar conte√∫do ao j√° rastreado pelo
Git para percebermos o funcionamento. Escrever uma lista de raz√µes para
usar o Linux. Deixei a lista curta poder ampliar no futuro e com erros
de portugu√™s para corrigir depois.

<!--
Frases do Linus Torvalds.
http://www.diolinux.com.br/2015/04/13-frases-epicas-de-linus-torvalds.html
-->

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Adiciona mais linhas ao README.txt
echo "
A filosofia do Linux √© 'Ria na face do perigo'.
√îpa. Errado. 'Fa√ßa voc√™ mesmo'. √â, √© essa.
                            -- Lunus Torvalds" >> README.txt

## Cria uma lista de pontos sobre o porqu√™ de usar o Linux.
echo "Por que usar o Linux?

* √â livre
* √â seguro
* √â customizavel" > porqueLinux.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra o conte√∫do do arquivo.
less README.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra o conte√∫do do arquivo.
less porqueLinux.txt
```

E o que o Git "acha" de tudo isso? O comando *status* √© o mais usado do
Git, principalmente nas etapas de aprendizado. Uma caracter√≠stica
diferente do Git, se comparado a outras aplica√ß√µes de uso por terminal,
√© que ele √© realmente camarada. Nas mensagens de *output*, o Gitque
informa o que aconteceu e tamb√©m d√° sugest√µes do que fazer.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

O Git retornou dois campos. No primeiro ele diz que existem mudan√ßas no
`README.txt` n√£o encaminhadas para receber registro (*not staged for
commit*) e no segundo ele aponta que o `porqueLinux.txt` √© um arquivo
n√£o rastreado (fora de monitoramento).

Vamos explorar um pouco mais os recursos do Git antes de adicionar as
recentes mudan√ßas. At√© o momento, temos apenas um *commit* feito. Para
acessar o hist√≥rico de registros usamos `git log`. O hist√≥rico mostra o
*sha1*, o autor, data e mensagem de *commit*. Uma sa√≠da mais enxuta √©
obtida com `git log --oneline`, √∫til quando o hist√≥rico √© longo. √â
poss√≠vel fazer restri√ß√£o no `git log`, como mostrar os *commits* a
partir de certa data, certo intervalo de datas, para um √∫nico autor ou
√∫nico arquivo. Visite: [git-log][].

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra o hist√≥rico de commits.
git log
```

O comando *diff* mostra as diferen√ßas no conte√∫do dos
arquivos/diret√≥rio. No caso, apenas o `README.txt` est√° sendo rastreado,
por isso o *output* indica a adi√ß√£o (`+`) de novas linhas. Na sa√≠da
tem-se os *sha1* das vers√µes comparadas e o intervalo de linhas
envolvido na por√ß√£o modificada (`@@`). Visite: [git-diffs][].

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Diferen√ßa nos arquivos versionados.
git diff
```

Vamos aplicar o primeiro *add* ao `porqueLinux.txt` para que ele come√ße
a ser versionado. Perceba que ao adicion√°-lo, as mudan√ßas, no caso a
cria√ß√£o do arquivo com cont√∫do, j√° s√£o separadas para receber registro
(*changes to be commited*).

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Adiciona o arquivo ao processo de reastreamento.
git add porqueLinux.txt
git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mensagem que registra as modifica√ß√µes adicionadas.
git commit -m "Lista de inicial de o porqu√™ usar o Linux."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

Ainda resta o `REAMDE.txt` para receber registro. Voc√™ n√£o precisa fazer
agora. Pode continuar editanto caso n√£o tenha atingido uma quantidade de
modifica√ß√£o merecedora de *commit*. Lembre-se que registros geram
conte√∫do no diret√≥rio `.git`. Quanto mais *commits*, mais conte√∫do
gerado. Mas tamb√©m, toda vez que voc√™ faz um *commit*, voc√™ define um
ponto de retorno, um estado salvo, caso precise no futuro
recuperar/visitar. O que √© uma unidade de modifica√ß√£o comit√°vel voc√™ ir√°
definir aos poucos com a pr√°tica.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Encaminha o arquivo para receber registro.
git add README.txt
git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Atribui mensagem de notifica√ß√£o.
git commit -m "Adiciona frase do Linux Torvalds."
```

Agora temos 3 *commits* e o *log* apresenta os *sha1* e as mensagens
correspondentes aos mesmos. Com `--oneline` resumimos o *output* mostrando
apenas o *sha1* e a mensagem de *commit*.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --oneline
```

Por meio dos *sha1*, podemos aplicar o *diff* para visitarmos as
modifica√ß√µes entre dois *commits*, n√£o necessariamente consecutivos, por
exemplo. Tamb√©m podemos retroceder (*checkout*, *reset*, *revert*) o
projeto para alguns desses pontos.

Abaixo instru√≠mos o Git mostrar as diferen√ßas para um *commit* atr√°s. A
cabe√ßa (*HEAD*) √© o que se entende como estado mais recente. Usa-se o
termo *HEAD* (cabe√ßa) pois considera-se um crescimento do hist√≥rico
debaixo para cima no qual um novo *commit* √© colocado em cima dos demais
(empilhado). O `HEAD@{0}` ou apenas `HEAD` representa o √∫ltimo registro
feito. N√£o √© necess√°rio escrever o √∫ltimo `HEAD` na intru√ß√£o abaixo.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git diff HEAD@{1}
```

Agora inspecionado uma dist√¢ncia de 2 *commits* a partir do √∫ltimo. Aqui
tem-se os dois arquivos envolvidos nesse intervalo de 2 *commits*. Com
`--name-only` retorna-se s√≥ o nome dos arquivos.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git diff HEAD@{2} HEAD@{0}
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git diff --name-only HEAD@{2} HEAD@{0}
```

Vamos resolver logo o caso da palavra sem acento em
`porqueLinux.txt`. Voc√™ abre o arquivo no seu editor de texto e modifica
conforme necess√°rio. A modifica√ß√£o compreende um linha apenas mas a√≠
lembrei de mais coisas e acrescentei. O `git diff` mostra as
diferen√ßas. Epa! As diferen√ßas n√£o eram entre *commits*? O conte√∫do
adicionado ainda n√£o recebeu notifica√ß√£o!

```{r, engine="bash", include=FALSE}
cd meu1repo

echo "Por que usar o Linux?

* √â livre
* √â seguro
* √â customiz√°vel
* Tem reposit√≥rios de software
* Atualiza√ß√£o constante
* Desempenho" > porqueLinux.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Depois de corrigir palavras e adicionar conte√∫do.
git status
```

O Git sugere voc√™ aplicar *add* para preparar para *commit*. Caso as
modifica√ß√µes sejam um engano e n√£o mais desejadas, voc√™ pode
desfazaz√™-las, abadonar a corre√ß√£o/inclus√£o das palavras usando
`checkout`. Vamos aplic√°-lo para ver como funciona.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Palavras corrigidas e mais itens adicionados.
less porqueLinux.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Abandona modifica√ß√µes feitas presentes no arquivo.
git checkout -- porqueLinux.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

less porqueLinux.txt
```

Bateu o arrependimento? Tem formas de poder retroceder com mudan√ßas
ainda n√£o registradas mas mantendo a possibilidade de
recuper√°-las. Mostraremos em breve.

**NOTA**: sempre que quiser testar um comando novo e n√£o est√° seguro do
que ele faz ou da extens√£o dos seus efeitos, fa√ßa uma c√≥pia do projeto
em outro diret√≥rio e experimente ele l√°. Isso previne sabores amargos,
pois algumas a√ß√µes podem ser irrevers√≠veis.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Depois de desfazer as modifica√ß√µes no porqueLinux.txt
git status
```

Vamos seguir com as modifica√ß√µes em `porqueLinux.txt` que corrigem o
texto e acrescentam itens novos.

```{r, engine="bash", include=FALSE}
cd meu1repo

echo "Por que usar o Linux?

* √â livre
* √â seguro
* √â customiz√°vel
* Tem reposit√≥rios de software
* Atualiza√ß√£o constante
* Desempenho" > porqueLinux.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

O `diff` vazio compara o diret√≥rio de trabalho com o √∫ltimo registro
(√∫ltimo *commit*). Quando voc√™ usa explicitamente na instru√ß√£o `HEAD@{ }`
seguido de n√∫mero, ent√£o est√£o sendo comparadas vers√µes
"commitadas". Existem variantes de sufixo para usar no `HEAD` que s√£o:

  * `HEAD@{n}`
  * `HEAD^n`
  * `HEAD~n`

em que `n` √© um n√∫mero inteiro n√£o negativo. Cada sulfixo tem uma
finalidade que n√£o detalharemos agora. Visite: [git-caret-and-tilde][].

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Modifica√ß√µes no diret√≥rio vs √∫ltimo commit.
git diff
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## √öltimo commit vs dois ancestrais, usando ~.
git diff HEAD~1 HEAD~0
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## √öltimo commit vs seu ancestral, usando @{}.
git diff HEAD@{1} HEAD@{0}
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## √öltimo commit vs dois ancestrais.
## git diff HEAD~2 HEAD~0
git diff HEAD@{2} HEAD@{0}
```

Para ficar claro daqui em diante, voc√™ pode ao inv√©s de pedir `log`,
pedir o `reflog` que inclu√≠ as refer√™ncias em termos da sequ√™ncia do
mais rencente para os seus ancestrais.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra refer√™ncias para commits os ancentrais.
git reflog
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Adiciona e commita.
git add porqueLinux.txt
git commit -m "Novos argumentos."
```

O Git permite um n√≠vel de rastreabilidade bem fino. Veja por exemplo que
√© poss√≠vel saber quem modificou e quando cada linha do arquivo e qual o
correspondente *sha1* do *commit*.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra quem, onde e o que fez em cada arquivo.
git blame README.txt
```

****
## Fazendo c√≥pias e trabalhando com ramos

Existem v√°rias formas de se trabalham com ramos. Geralmente os ramos s√£o
feitos sob demandas para adicionar uma caracter√≠stica ao projeto
(*feature*) ou corrigir um *bug*. Alguns ramos, por outro lado, s√£o
ramos fixos destinados a receber o desenvolvimento dos ramos de
demanda. Esses ramos s√£o geralmente chamados de *devel* (*development*)
e *release*. O ramo *master* √© o default e em geral, para projetos
grandes, o *master* s√≥ recebe vers√µes funcionais do projeito, livre de
bugs.

Para criar um ramo, usandos `git branch` seguido do nome que se
deseja. Vamos criar um ramo para adicionar mais arquivos ou modifica√ß√µes
ao projeto.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Lista ramos (all), locais e remotos.
## git branch    ## S√≥ ramos locais
## git branch -r ## S√≥ ramos remotos
git branch -a ## Todos os ramos.
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Cria um ramo para adi√ß√£o de conte√∫do, novo segmento.
git branch feature01
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Novo ramo criado aparece.
git branch
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Muda o HEAD de ramo.
git checkout feature01
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Situa√ß√£o no novo ramo.
git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Hist√≥rico de commits.
git log --oneline
```

Veja que o novo ramo n√£o come√ßa no zero ou vazio (sem arquivos) e sim a
partir do ramo que √© seu ancestral, ou seja, ele come√ßa a partir do
√∫ltimo *commit* existente, por padr√£o. Vamos adicionar um arquivo e
commitar. O comando `wget` permite baixar arquivos pelo terminal. Ser√°
baixado um arquivo com um fun√ß√£o para calcular o fator de infla√ß√£o de
vari√¢ncia (*vif*, variance inflation factor) usado em modelos de
regress√£o, dispon√≠vel na p√°gina da [Professora Suely Giolo][].

```{r, engine="bash", include=FALSE}
## Tenta ir para o diret√≥rio downloads, se n√£o conseguir √© porque n√£o
## existe ent√£o cria um diret√≥rio download para ent√£o entrar nele.
if [ -d downloads ]
then
    echo "Diret√≥rio existe."
    cd downloads
else
    echo "Diret√≥rio n√£o existe."
    mkdir downloads
    cd downloads
fi

## Se n√£o existir o aquivo vif.R, ent√£o baixar da internet.
if [ ! -f vif.R ]
then
    echo "Arquivo vif.R n√£o existe. Baixando..."
    wget 'http://people.ufpr.br/~giolo/CE071/Exemplos/vif.R'
else
    echo "Arquivo vif.R j√° existe."
fi

## Copiar o arquivo vif.R para o meu1repo (-v: verbose).
cp -v vif.R ../meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## Baixando arquivo da internet. Uma fun√ß√£o do R.
wget 'http://people.ufpr.br/~giolo/CE071/Exemplos/vif.R'
```

```{r, engine="bash", echo=FALSE}
## Printa o seria o output da wget mas sem usar a wget para n√£o
## encarecer a compila√ß√£o. Insere o instante da compila√ß√£o. Esconde
## tamb√©m o IP da m√°quina com ???.??.???.??.

cat << EOF
--$(date +"%Y-%m-%d %H:%M:%S")--  http://people.ufpr.br/~giolo/CE071/Exemplos/vif.R
Resolving people.ufpr.br (people.ufpr.br)... ???.??.???.??, 2801:82:8020:0:8377:0:100:20
Connecting to people.ufpr.br (people.ufpr.br)|???.??.???.??|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 560
Saving to: ‚Äòvif.R‚Äô

     0K                                                       100% 44,0M=0s

$(date +"%Y-%m-%d %H:%M:%S") (44,0 MB/s) - ‚Äòvif.R‚Äô saved [560/560]
EOF
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Situa√ß√£o do reposit√≥rio ap√≥s o download.
git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git add vif.R
git commit -m "Adiciona fun√ß√£o R para VIF."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Estrutura do diret√≥rio.
tree
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Hist√≥rico de commits.
git reflog
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

Ent√£o acabamos de acrescentar um novo aquivo ao projeto. Agora que as
modifica√ß√µes foram salvas (*commit* feito) podemos trocar de ramo. Voc√™
vai ver que ao voltarmos para o ramo *master* o arquivo baixado da
internet vai "desaparecer".

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Volta para o ramo master.
git checkout master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Estrutura do diret√≥rio.
tree
```

O arquivo `vif.R` n√£o sumiu. Ele est√° no ramo `feature01` e s√≥ passar√°
para o ramo master quando mesclarmos o que existe no `feature01` ao
`master`. Ent√£o √© assim: mudou de ramo, muda o conte√∫do do
diret√≥rio. Fazer isso √© bem simples, basta dar um `git merge`. Antes
vamos aprender como saber as diferen√ßas que existem entre ramos.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra todas as modifica√ß√µes, cada linha modificada de cada arquivo.
git diff master feature01
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra s√≥ os arquivos modificados.
git diff --name-only master feature01
```

Como voc√™ j√° havia antecipado, a √∫nica diferen√ßa entre os ramos `master`
e `feature01` √© o arquivo `vif.R`. Agora √© s√≥ pedir o `git merge`.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mesclando as modifica√ß√µes em feature01 no master.
git merge feature01 master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --oneline
```

√â poss√≠vel criar um ramo a partir de um *commit* ancestral ao atual. Isso
√© extremamente √∫til para resolver os bugs. Vamos fazer um segundo ramo a
partir do *commit* anterior a inclus√£o do arquivo R.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Referencias aos commits.
git reflog
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Volta para antes do arquivo de baixar o vif.R.
git checkout HEAD@{4}
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Qual a situa√ß√£o.
git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## O hist√≥rio existente nesse ponto.
git log --name-only --oneline
```

J√° que o *commit* mais recente dessa hist√≥ria aponta para o arquivo
compras, vamos checar o seu conte√∫do apenas por medida de seguran√ßa.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra o conte√∫do do arquivo.
less porqueLinux.txt
```

Dito e feito! Voltamos no tempo para o instante logo ap√≥s o *commit* que
inclu√≠ novos itens na lista. Podemos voltar para o presente se
estivermos satisfeitos com o passeio mas tamb√©m podemos criar um ramo
aqui, caso isso seja necess√°rio. Primeiro vamos voltar para o presente
depois mostramos como criar o ramo.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra onde estamos.
git branch
```

Se n√£o fizemos nenhuma modifica√ß√£o, voltar √© bem simples. Se
modifica√ß√µes foram feitas √© necess√°rio saber se precisam ser mantidas e
onde ou se devem ser descartadas.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Volta para o presente.
git checkout master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --oneline
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Fenda no tempo fechada. Sem sinal do detached HEAD.
git branch
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Sinal do passeio no tempo.
git reflog
```

Vamos come√ßar a ser ousados. Vamos voltar no passado, adicionar um
arquivo, commitar e ver o que acontece, como o hist√≥rico √© representado.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Volta no tempo, ap√≥s commit que aumenta porqueLinux.txt.
git checkout HEAD@{6}
```

```{r, engine="bash", include=FALSE}
## Tenta ir para o diret√≥rio downloads, se n√£o conseguir √© porque n√£o
## existe ent√£o cria um diret√≥rio download para ent√£o entrar nele.
if [ -d downloads ]
then
    echo "Diret√≥rio existe."
    cd downloads
else
    echo "Diret√≥rio n√£o existe."
    mkdir downloads
    cd downloads
fi

## Se n√£o existir o aquivo pimentel_racoes.txt, ent√£o baixar da internet.
if [ ! -f pimentel_racoes.txt ]
then
    echo "Arquivo pimentel_racoes.txt n√£o existe. Baixando..."
    wget 'http://www.leg.ufpr.br/~walmes/data/pimentel_racoes.txt'
else
    echo "Arquivo pimentel_racoes.txt j√° existe."
fi

## Copiar o arquivo pimentel_racoes.txt para o meu1repo (-v: verbose).
cp -v pimentel_racoes.txt ../meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## Baixa arquivo de dados da internet.
wget 'http://www.leg.ufpr.br/~walmes/data/pimentel_racoes.txt'
```

```{r, engine="bash", echo=FALSE}
## Printa o seria o output da wget mas sem usar a wget para n√£o
## encarecer a compila√ß√£o. Insere o instante da compila√ß√£o. Esconde
## tamb√©m o IP da m√°quina com ???.??.???.??.

cat << EOF
--(date +"%Y-%m-%d %H:%M:%S")--  http://www.leg.ufpr.br/~walmes/data/pimentel_racoes.txt
Resolving www.leg.ufpr.br (www.leg.ufpr.br)... ???.??.???.??
Connecting to www.leg.ufpr.br (www.leg.ufpr.br)|???.??.???.??|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 217 [text/plain]
Saving to: ‚Äòpimentel_racoes.txt‚Äô

     0K                                                       100% 68,9M=0s

(date +"%Y-%m-%d %H:%M:%S") (68,9 MB/s) - ‚Äòpimentel_racoes.txt‚Äô saved [217/217]

‚Äòpimentel_racoes.txt‚Äô -> ‚Äò../meu1repo/pimentel_racoes.txt‚Äô
EOF
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Adiciona para registrar a inclus√£o do arquivo.
git add pimentel_racoes.txt
git commit -m "Adiciona aquivo de dados de experimento com ra√ß√µes."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Log num formato gr√°fico ASCII para mostrar o novo ramo.
git log --graph --oneline --decorate --date=relative --all
```

No nosso projeto temos o *master* e o *feature01* em igual condi√ß√£o, sem
nenhuma diferen√ßa. O *commit* rec√©m feito indica um novo seguimento a
partir daquele onde adicionamos novos itens na lista. Vamos criar um
novo ramo porque atualmente estamos em um ramos suspenso (*detached
HEAD*) que n√£o √© persist√™nte.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git branch
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Um novo ramo a partir do atual HEAD.
git checkout -b feature02
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git branch
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

Vamos explorar bem a funcionalidade. Vamos voltar para o `feature01` e
criar mais coisas l√°. Voc√™ j√° deve estar pensando que tudo isso √©
absurdo e jamais algu√©m firaria indo e voltando assim. Voc√™ est√° certo,
por√©m, quando o projeto envolve mais pessoas, cerrtamente as coisas ir√£o
bifurcar em algum ponto.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git checkout feature01
```

```{r, engine="bash", echo=FALSE}
## Tenta ir para o diret√≥rio downloads, se n√£o conseguir √© porque n√£o
## existe ent√£o cria um diret√≥rio download para ent√£o entrar nele.
if [ -d downloads ]
then
    echo "Diret√≥rio existe."
    cd downloads
else
    echo "Diret√≥rio n√£o existe."
    mkdir downloads
    cd downloads
fi

## Se n√£o existir o aquivo brasilCopa2014.txt, ent√£o baixar da internet.
if [ ! -f brasilCopa2014.txt ]
then
    echo "Arquivo brasilCopa2014.txt n√£o existe. Baixando..."
    wget 'http://www.leg.ufpr.br/~walmes/cursoR/geneticaEsalq/brasilCopa2014.txt'
else
    echo "Arquivo brasilCopa2014.txt j√° existe."
fi

## Copiar o arquivo brasilCopa2014.txt para o meu1repo (-v: verbose).
cp -v brasilCopa2014.txt ../meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

wget 'http://www.leg.ufpr.br/~walmes/cursoR/geneticaEsalq/brasilCopa2014.txt'
```

```{r, engine="bash", echo=FALSE}
## Printa o seria o output da wget mas sem usar a wget para n√£o
## encarecer a compila√ß√£o. Insere o instante da compila√ß√£o. Esconde
## tamb√©m o IP da m√°quina com ???.??.???.??.

cat << EOF
--$(date +"%Y-%m-%d %H:%M:%S")--  http://www.leg.ufpr.br/~walmes/cursoR/geneticaEsalq/brasilCopa2014.txt
Resolving www.leg.ufpr.br (www.leg.ufpr.br)... ???.??.???.??
Connecting to www.leg.ufpr.br (www.leg.ufpr.br)|???.??.???.??|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1254 (1,2K) [text/plain]
Saving to: ‚ÄòbrasilCopa2014.txt‚Äô

     0K .                                                     100% 69,6M=0s

$(date +"%Y-%m-%d %H:%M:%S") (69,6 MB/s) - ‚ÄòbrasilCopa2014.txt‚Äô saved [1254/1254]
EOF
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git add brasilCopa2014.txt
git commit -m "Arquivo sobre copa 2014 cele√ß√£o brasileira."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

Agora nos temos o *feature01* na frente do master e o *feature02* ao
lado. O conte√∫do dos dois ramos ter√° que ser incorporado ao *master* em
algum momento porque √© assim que funciona. Mas n√£o h√° raz√µes para
preocupa√ß√£o pois o prop√≥sito do Git √© justamente facilitar esse
processo. Nesse caso, por exemplo, como as diferen√ßas nos ramos consiste
na adi√ß√£o de arquivos diferentes, incorporar as modifica√ß√µes no *master*
ser√° uma tarefa simples para o Git. O agravante √© quando em dois ramos
(ou duas pessoas) o mesmo arquivo √© modificado no mesmo intervalo de
linhas. Nessa situa√ß√£o o *merge* nos arquivos deve ser supervisionado e
n√£o autom√°tico. Vamos incorporar as modifica√ß√µes dos ramos ao master
ent√£o.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Volta para o master.
git checkout master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mescla o feature01.
git merge feature01 master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mescla o feature02.
git merge feature02 master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

tree
```

****
## Resolvendo conflitos

Agora vamos de prop√≥sito mostrar uma situa√ß√£o em que n√£o √© poss√≠vel
fazer o merge automaticamente. Vamos criar um conflito. Para isso vou
criar um ramo novo, modificar o arquivo na √∫ltima linha e commitar. Vou
voltar par ao *master* e fazer o mesmo mas vou usar um texto diferente
para incluir no arquivo. J√° que os ramos *feature01* e *feature02* n√£o
s√£o mais necess√°rios, podemos remov√™-los. No entanto, eles permanecem na
hist√≥ria do projeto e poder resurgir se voc√™ voltar no tempo.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Remove ramos.
git branch -d feature01
git branch -d feature02
git branch
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

Agora vou criar um novo ramo, adicionar um arquivo e encurtar o nome das
colunas no cabe√ßalho.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Muda para um ramo criado na hora.
git checkout -b feature03
```

```{r, engine="bash", include=FALSE}
## Tenta ir para o diret√≥rio downloads, se n√£o conseguir √© porque n√£o
## existe ent√£o cria um diret√≥rio download para ent√£o entrar nele.
if [ -d downloads ]
then
    echo "Diret√≥rio existe."
    cd downloads
else
    echo "Diret√≥rio n√£o existe."
    mkdir downloads
    cd downloads
fi

## Se n√£o existir o aquivo bib1.txt, ent√£o baixar da internet.
if [ ! -f bib1.txt ]
then
    echo "Arquivo bib1.txt n√£o existe. Baixando..."
    wget 'http://www.leg.ufpr.br/~walmes/data/bib1.txt'
else
    echo "Arquivo bib1.txt j√° existe."
fi

## Copiar o arquivo bib1.txt para o meu1repo (-v: verbose).
cp -v bib1.txt ../meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## Baixa o arquivo.
wget 'http://www.leg.ufpr.br/~walmes/data/bib1.txt'
```

```{r, engine="bash", echo=FALSE}
## Printa o seria o output da wget mas sem usar a wget para n√£o
## encarecer a compila√ß√£o. Insere o instante da compila√ß√£o. Esconde
## tamb√©m o IP da m√°quina com ???.??.???.??.

cat << EOF
--$(date +"%Y-%m-%d %H:%M:%S")--  http://www.leg.ufpr.br/~walmes/data/bib1.txt
Resolving www.leg.ufpr.br (www.leg.ufpr.br)... ???.??.???.??
Connecting to www.leg.ufpr.br (www.leg.ufpr.br)|???.??.???.??|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 535 [text/plain]
Saving to: ‚Äòbib1.txt‚Äô

     0K                                                       100% 35,0M=0s

$(date +"%Y-%m-%d %H:%M:%S") (35,0 MB/s) - ‚Äòbib1.txt‚Äô saved [535/535]
EOF
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Mostra as 4 primeiras linhas.
head -4 bib1.txt
```

Ao encurtar o nome para quatro d√≠gitos, fica assim.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Substitui o conte√∫do da primeira linha pelos nomes truncados em 4
## d√≠gidos e separados por tabula√ß√£o. Etapa que voc√™ pode fazer no seu
## editor de texto.
sed -i "1s/.*/rept\tvari\tbloc\ty/" bib1.txt
head -4 bib1.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git add bib1.txt
git commit -m "Arquivo de experimento em BIB. Trunca cabe√ßalho 4 digitos."
```

Baixamos e modificamos o arquivo. Adicionamos e fizemos o registro das
modifica√ß√µes. Agora vamos voltar ao *master* e baixar o arquivo tamb√©m,
fazendo de conta que √© outra pessoa trabalhando no mesmo projeto, mas
essa pessoa vai passar a cabe√ßalho para caixa alta.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git checkout master
```

```{r, engine="bash", include=FALSE}
## Copiar o arquivo bib1.txt para o meu1repo (-v: verbose).
cd downloads
cp -v bib1.txt ../meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## Baixa o arquivo.
wget 'http://www.leg.ufpr.br/~walmes/data/bib1.txt'
```

Ao encurtar o nome para quatro d√≠gitos, fica assim.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Substitui o conte√∫do da primeira linha pelo mesmo em caixa alta. Fa√ßa
## isso no seu editor de texto de preferido.
sed -i '1s/.*/\U&/' bib1.txt
head -4 bib1.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git add bib1.txt
git commit -m "Arquivo de experimento em BIB. Cabe√ßalho em caixa alta."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git diff master feature03
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd meu1repo

## D√° mensagem de erro que informa o conflito.
git merge feature03 master
```

```{r, warning=FALSE, echo=FALSE}
x <- system("cd meu1repo && git merge feature03 master", intern=TRUE)
cat(paste(x, collapse="\n"))

```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## `less` printa o conte√∫do do arquivo mas `head` limita para 10 linhas.
less bib1.txt | head -10
```

Ent√£o deu conflito e o Git informa que ele deve ser resolvido. Resolver
o conflito aqui significa abrir os arquivos com problema listados no git
status e editar de tal forma a desconflitar. Nas regi√µes de conflito o
Git sinaliza de forma especial, indicando por divis√≥rias (`<<<<<<<`,
`=======` e `>>>>>>>`) as vers√µes no HEAD (ramo *master*) e no ramos a
ser incorporado (*feature03*). Ent√£o vamos resolver o conflito sem
favorecer ningu√©m, ou seja, vamos encurtar para 4 digitos e manter caixa
alta. Dessa forma o aquivo fica assim.

```{r, engine="bash", echo=-c(1:2), include=FALSE}
cd meu1repo

sed -i '1,3d;5d' bib1.txt
sed -i '1s/.*/\U&/' bib1.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

## Arquivo depois da edi√ß√£o que resolve o conflito.
head -6 bib1.txt
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git add bib1.txt
git commit -m "Resolve conflito, trunca com caixa alta."
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git reflog
```

## Trabalhando com c√≥pias

```{r, engine="bash", include=FALSE}
if [ -d ~/maquina2/ ]
then
    echo "Diret√≥rio existe. Ent√£o apagar pasta meu1repo."
    cd ~/maquina2/
    ls -a
    if [ -d meu1repo ]
    then
        echo "J√° existe meu1repo aqui. Apagar."
        rm -rf meu1repo
    fi
else
    echo "Diret√≥rio n√£o existe."
    mkdir ~/maquina2/
fi

## Tudo limpo tal como precisamos.
pwd
ls -a

```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git remote -v
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2

## Diret√≥rio na segunda que ter√° uma c√≥pia em desenvolvimento do
## projeto.
pwd
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2

## Conte√∫do.
tree -a
```

```{r, engine="bash", echo=-c(1:2)}
DIRGIT=$PWD; cd ~/maquina2

## Clonando o projeto de outro lugar.
## $DIRGIT representa o caminho para chegar at√© meu1repo.
git clone "$DIRGIT/meu1repo/.git" && cd meu1repo
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2

## Conte√∫do ap√≥s clonar.
tree
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git remote -v
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git log --oneline
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git branch -a
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git branch feature04
git checkout feature04
```

```{r, engine="bash", include=TRUE}
## Tenta ir para o diret√≥rio downloads, se n√£o conseguir √© porque n√£o
## existe ent√£o cria um diret√≥rio download para ent√£o entrar nele.
if [ -d downloads ]
then
    echo "Diret√≥rio existe."
    cd downloads
else
    echo "Diret√≥rio n√£o existe."
    mkdir downloads
    cd downloads
fi

## Se n√£o existir o aquivo diasbarros_feijao.txt, ent√£o baixar da
## internet.
if [ ! -f diasbarros_feijao.txt ]
then
    echo "Arquivo diasbarros_feijao.txt n√£o existe. Baixando..."
    wget 'http://www.leg.ufpr.br/~walmes/data/diasbarros_feijao.txt'
else
    echo "Arquivo diasbarros_feijao.txt j√° existe."
fi

## Copiar o arquivo diasbarros_feijao.txt para o meu1repo (-v: verbose).
cp -v diasbarros_feijao.txt ~/maquina2/meu1repo/
```

```{r, engine="bash", echo=-c(1:2), eval=FALSE}
cd ~/maquina2/meu1repo

## Baixa o arquivo.
wget 'http://www.leg.ufpr.br/~walmes/data/diasbarros_feijao.txt'
```

```{r, engine="bash", echo=FALSE}
## Printa o seria o output da wget mas sem usar a wget para n√£o
## encarecer a compila√ß√£o. Insere o instante da compila√ß√£o. Esconde
## tamb√©m o IP da m√°quina com ???.??.???.??.

cat << EOF
--$(date +"%Y-%m-%d %H:%M:%S")--  http://www.leg.ufpr.br/~walmes/data/diasbarros_feijao.txt
Resolving www.leg.ufpr.br (www.leg.ufpr.br)... ???.??.???.??
Connecting to www.leg.ufpr.br (www.leg.ufpr.br)|???.??.???.??|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 487 [text/plain]
Saving to: ‚Äòdiasbarros_feijao.txt‚Äô

     0K                                                       100% 40,2M=0s

$(date +"%Y-%m-%d %H:%M:%S") (40,2 MB/s) - ‚Äòdiasbarros_feijao.txt‚Äô saved [487/487]
EOF
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git add diasbarros_feijao.txt
git commit -m "Dados de experimento com feij√£o."
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git push origin feature04
```

Volta para origem e verifica o que recebeu de contribui√ß√£o.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

pwd
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git status
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git branch -a
```

Opa! Tem um novo ramo. Vamos ver o que ele tem de diferente.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git diff --name-only feature04 master
```

Parece que chegou um arquivo novo. Vamos ent√£o mesclar ao master.

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git merge feature04 master
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log --graph --oneline --decorate --date=relative --all
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

pwd
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git pull origin master
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git log --graph --oneline --decorate --date=relative --all
```

```{r, engine="bash", echo=-c(1:2)}
cd ~/maquina2/meu1repo

git log --stat
```

```{r, engine="bash", echo=-c(1:2)}
cd meu1repo

git log -p -2
```

```{r, include=FALSE}
## STOP
opts_chunk$set(eval=FALSE)
```

****
## Ignorando arquivos e diret√≥rios

****
## Autenticando em contas do GitLab (c3sl) e GitHub

Os procedimentos dessa sess√£o tem o objetivo de promover o conex√£o da
sua m√°quina de trabalho com sua conta no GitLab do c3sl (alunos UFPR) ou
conta do GitHub. Assume-se, logicamente, que voc√™ tenha conta em algum
desses servi√ßos. Caso voc√™ n√£o tenha uma conta em algum servi√ßo de
hospedagem de repsit√≥rio Git, seguem algumas op√ß√µes:

  * GitHub: <https://github.com/>
  * GitLab: <https://about.gitlab.com/>
  * Bitbucket: <https://bitbucket.org/>

Uma compara√ß√£o entre os servi√ßos dispon√≠veis para Git est√° dispon√≠vel em
[git-hosting-services-compared][].

Abra o terminal em qualquer diret√≥rio. N√£o precisa ser um diret√≥rio
Git. Aqui ser√° criado um par de chaves, que nada mais s√£o que longas
cadeias de caracteres, de forma que elas formam um par
chave/cadeado. A p√∫blica (a chave) √© copiada para o servidor. A privada
fica na sua m√°quina. Dessa maneira, a comunica√ß√£o para transfer√™ncia de
dados entre as m√°quinas pode ser feita.

Ser√° solicitado uma senha (`passphrase`). Voc√™ pode forncer uma ou
apenas pressionar `Enter` para correr o procedimento padr√£o. O resultado
√© uma senha gr√°fica ASCII al√©m de gerar os arquivos (chaves) cujo
caminho √© informado no *output*.

```{r, engine="sh", eval=FALSE}
## keygen (chave gerar). rsa √© o tipo.
ssh-keygen -t rsa -C "batman@justiceleague.org"
```

```
Generating public/private rsa key pair.
Enter file in which to save the key (/home/batman/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/batman/.ssh/id_rsa.
Your public key has been saved in /home/batman/.ssh/id_rsa.pub.
The key fingerprint is:
66:c1:0b:3a:94:25:83:00:81:9f:40:26:f7:aa:af:3a batman@justiceleague.org
The key's randomart image is:
          +--[ RSA 2048]----+
          |                 |
 ~MMMMMMMMMMMM           MMMMMMMMMMMM~  
    .MMMMMMMMM.   MMM   .MMMMMMMMM.     
      MMMMMMMMMMMMMMMMMMMMMMMMMMM       
       MMMMMMMMMMMMMMMMMMMMMMMMM       
      .MMMMMMMMMMMMMMMMMMMMMMMMM.        
              .MMMMMMMMM.               
                 .MMM.                  
                   M                    
          |                 |
          +-----------------+
```

O importante √© o conte√∫do do arquivo `/home/batman/.ssh/id_rsa.pub`, a
sua chave p√∫blica. Este deve ser fornecido ao GitLab (ou GitHub) em uma
janela com as chaves. Os endere√ßos abaixo levam para a mencionada
janela. Requer que esteja logado.

  * GitLab: <http://gitab.c3sl.ufpr.br/profile/keys>
  * GitHub: <https://github.com/settings/ssh>

Nessa janela dever√° ser informado o c√≥digo gerado pelo
`ssh-keygen`. Voc√™ deve copiar o texto do arquivo
`/home/batman/.ssh/id_rsa.pub`, sem mofic√°-lo, e fornecer ao GitLab.
Para ver/abrir o conte√∫do do arquivo no pr√≥prio terminal use `less` ou
`cat`. Para copiar do terminal use `ctrl+shift+c`. Para abrir com um
editor de texto, o `gedit` por exemplo, √© s√≥ passar o nome do arquivo.

```sh
## Abre o arquivo com o editor de texto Gedit.
gedit /home/batman/.ssh/id_rsa.pub

## Mostra o conte√∫do do arquivo no pr√≥prio terminal.
less /home/batman/.ssh/id_rsa.pub  
```

```
ssh-rsa BBBBB3NzaC1yc2EAAAADAQABAAABAQDDuQmvkQ0WgwYQvR16z37tG37Q61ID+Qf4hi8+cARjjSWP7015CAtRnCvmGFSbdFMjz3ZEkp2XzHIyRCKw2hLP57rkFcfioWra6N5/9+z+tPiwr2OzwLfk7J/GAETGA4rtoToV96hf5RvKRhvuqyO5uf5ouBILm1PRpjA/5AkfToWp25/7WC136eGIOSJMFgQ3OuK5U+qSXAwuSdu9Uj1XkVYFDjasA45ZjsnkE6L9bKiYymadshEbWEBHJAWqDErd8srMtBYS/2hodNnjfH7rNHHCo8wZD5GJFz7YUodaBSaSYuHVfrEryaEm/r5787CAiecFAjWEeVq6StM7N/lz batman@justiceleague.org
```

Para conferir a comunica√ß√£o da sua m√°quina com o servidor do GitLab do
c3sl ou do GitHub, aplique a instru√ß√£o `ssh` abaixo.

```sh
## Com gitlab do c3sl.
ssh -T git@gitlab.c3sl.ufpr.br
```

```
Welcome to GitLab, Knight Rider!
```

```sh
## Com github.
ssh -T git@github.com
```

```
Hi batman! You've successfully authenticated, but GitHub does not provide shell access.
```

Em caso de obter uma mensagem n√£o positiva, repita o comando com a op√ß√£o
`-v` para um log do procedimento.

```sh
## Com gitlab do c3sl.
ssh -vT git@github.com
```

```
OpenSSH_6.6.1, OpenSSL 1.0.1f 6 Jan 2014
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 19: Applying options for *
debug1: Connecting to github.com [192.30.252.130] port 22.
debug1: Connection established.
debug1: identity file /home/batman/.ssh/id_rsa type 1
debug1: identity file /home/batman/.ssh/id_rsa-cert type -1
debug1: identity file /home/batman/.ssh/id_dsa type -1
debug1: identity file /home/batman/.ssh/id_dsa-cert type -1
debug1: identity file /home/batman/.ssh/id_ecdsa type -1
debug1: identity file /home/batman/.ssh/id_ecdsa-cert type -1
debug1: identity file /home/batman/.ssh/id_ed25519 type -1
debug1: identity file /home/batman/.ssh/id_ed25519-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.3
debug1: Remote protocol version 2.0, remote software version libssh-0.7.0
debug1: no match: libssh-0.7.0
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server->client aes128-ctr hmac-sha1 none
debug1: kex: client->server aes128-ctr hmac-sha1 none
debug1: sending SSH2_MSG_KEX_ECDH_INIT
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: RSA 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48
debug1: Host 'github.com' is known and matches the RSA host key.
debug1: Found key in /home/batman/.ssh/known_hosts:1
debug1: ssh_rsa_verify: signature correct
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: Roaming not allowed by server
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Offering RSA public key: /home/batman/.ssh/id_rsa
debug1: Server accepts key: pkalg ssh-rsa blen 279
debug1: Authentication succeeded (publickey).
Authenticated to github.com ([192.30.252.130]:22).
debug1: channel 0: new [client-session]
debug1: Entering interactive session.
debug1: Sending environment.
debug1: Sending env LC_PAPER = pt_BR.UTF-8
debug1: Sending env LC_ADDRESS = pt_BR.UTF-8
debug1: Sending env LC_MONETARY = pt_BR.UTF-8
debug1: Sending env LC_NUMERIC = pt_BR.UTF-8
debug1: Sending env LC_TELEPHONE = pt_BR.UTF-8
debug1: Sending env LC_IDENTIFICATION = pt_BR.UTF-8
debug1: Sending env LANG = en_US.UTF-8
debug1: Sending env LC_MEASUREMENT = pt_BR.UTF-8
debug1: Sending env LC_TIME = pt_BR.UTF-8
debug1: Sending env LC_NAME = pt_BR.UTF-8
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
Hi batman! You've successfully authenticated, but GitHub does not provide shell access.
debug1: channel 0: free: client-session, nchannels 1
Transferred: sent 3856, received 1784 bytes, in 0.4 seconds
Bytes per second: sent 10261.9, received 4747.7
debug1: Exit status 1
```

### Requisi√ß√µes de mescla

### Colaborando via fork

****
## Modelos de fluxos de trabalho

<!--
Inspira√ß√£o:

https://git-scm.com/book/pt-br/v1/Git-Distribu%C3%ADdo-Fluxos-de-Trabalho-Distribu%C3%ADdos
http://imasters.com.br/gerencia-de-ti/fluxo-de-desenvolvimento-com-gitflow/
http://www.magentonapratica.com.br/2014/07/um-modelo-bem-sucedido-de-ramificacao.html
-->

****
## Usando ferramentas gr√°ficas para o Git

### Git GUI

### Gitk

### Meld

****
## Dicion√°rio de termos

<!---------------------------------------------------------------------- -->
<!-- Refer√™ncias ------------------------------------------------------- -->

[Customizing Git - Git Configuration]: http://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration
[Setting up a repository]: https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config
[sha1-size]: http://stackoverflow.com/questions/18134627/how-much-of-a-git-sha-is-generally-considered-necessary-to-uniquely-identify-a
[git-log]: http://git-scm.com/docs/git-log
[Installing-Git]: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git
[**Git BASH**]: https://lostechies.com/derickbailey/files/2011/03/Screen-shot-2010-11-25-at-10.56.27-AM.png
[**Git GUI**]: http://www.davidegrayson.com/for_blog/entry/20130420_git_win8/git-gui.png
[**Shell Integration**]: http://planetozh.com/blog/wp-content/uploads/2012/11/pewpew.png
[**Gitk**]: http://www.davidegrayson.com/for_blog/entry/20130420_git_win8/git-history.png
[how-to-set-meld-as-git-mergetool]: http://stackoverflow.com/questions/12956509/how-to-set-meld-as-git-mergetool
[linuxmint/nemo]: https://github.com/linuxmint/nemo
[tree]: http://gnuwin32.sourceforge.net/packages/tree.htm
[Git contributing guide]: http://git.leg.ufpr.br/leg/gitlab-rautu/blob/master/CONTRIBUTING.md
[git-diffs]: http://www.git-tower.com/learn/git/ebook/command-line/advanced-topics/diffs
[git-caret-and-tilde]: http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde
[Professora Suely Giolo]: http://www.est.ufpr.br/prof/22-suely.html
[git-hosting-services-compared]: http://www.git-tower.com/blog/git-hosting-services-compared/